<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>From EC2 to Fargate</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">From EC2 to Fargate</h1>
</header>
<section data-field="subtitle" class="p-summary">
An introduction to the new container orchestration service from AWS
</section>
<section data-field="body" class="e-content">
<section name="bd7b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="592a" id="592a" class="graf graf--h3 graf--leading graf--title">From EC2 to Fargate</h3><h4 name="42c4" id="42c4" class="graf graf--h4 graf-after--h3 graf--subtitle">An introduction to the new container orchestration service from AWS</h4><h3 name="7cf4" id="7cf4" class="graf graf--h3 graf-after--h4">Problem</h3><figure name="55ac" id="55ac" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*SGjXPSF70ZGohRu5Ud6R_g.png" data-width="948" data-height="301" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*SGjXPSF70ZGohRu5Ud6R_g.png"><figcaption class="imageCaption">AWS diagrams, as usual, hiding the complexity of your final setup</figcaption></figure><p name="121d" id="121d" class="graf graf--p graf-after--figure">The diagram above is concerned only with Fargate and container orchestration. If you are build anything of moderate size you will need to consider much more beyond that.</p><p name="fc5c" id="fc5c" class="graf graf--p graf-after--p">You will need to consider what type of application you are deploying.</p><ul class="postList"><li name="616c" id="616c" class="graf graf--li graf-after--p">Are they under different domains and APIs?</li><li name="1d14" id="1d14" class="graf graf--li graf-after--li">How quick will you need to redeploy aspects of you infrastructure? Minutes, hours, days?</li><li name="bf9c" id="bf9c" class="graf graf--li graf-after--li">What is the security consideration of each app?</li><li name="40df" id="40df" class="graf graf--li graf-after--li">Do you need to secure some APIs and not others?</li><li name="69ea" id="69ea" class="graf graf--li graf-after--li">How will you deal with logging and monitoring?</li><li name="ac3f" id="ac3f" class="graf graf--li graf-after--li">Is it behind a load balancer?</li></ul><p name="6554" id="6554" class="graf graf--p graf-after--li">We also need to consider CI/CD pipelines which link to each of these new platforms.</p><h4 name="2406" id="2406" class="graf graf--h4 graf-after--p">Disclaimer</h4><p name="236f" id="236f" class="graf graf--p graf-after--h4"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">As described above you will need to setup VPCs, subnets, route tables, security groups. I could go on… This post will focus purely on Fargate and its setup.</em></strong></p><h3 name="b23b" id="b23b" class="graf graf--h3 graf-after--p">How we got there</h3><p name="67cb" id="67cb" class="graf graf--p graf-after--h3">Due to time constraints and the fact that Fargate did not exist at the time, the first version of our infrastructure deployed our applications to EC2 instances directly.</p><p name="e255" id="e255" class="graf graf--p graf-after--p">The EC2 instances were controlled by autoscaling groups to deal with increased load. Consul was used for service discovery in conjunction with Fabio as a reverse proxy. Packer was used to describe the underlying VM.</p><p name="3919" id="3919" class="graf graf--p graf-after--p">This setup was very fast to implement but had some major issues:</p><ul class="postList"><li name="3f09" id="3f09" class="graf graf--li graf-after--p">Wasteful since our applications did not use all the underlying EC2 resources</li><li name="be35" id="be35" class="graf graf--li graf-after--li">Deployments took down services since the EC2 instances have to be frequently restarted</li><li name="c661" id="c661" class="graf graf--li graf-after--li">Local testing was error prone since your could not simulate the EC2 environment completely</li></ul><p name="6736" id="6736" class="graf graf--p graf-after--li">One benefit to this is that you could have ssh access into the EC2 instances which meant you could debug certain bugs faster. However most of those bugs were created from not having immutable containers in the first place.</p><figure name="825f" id="825f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*MXwyz3kH8ne9PxepWUENjw.jpeg" data-width="400" data-height="300" src="https://cdn-images-1.medium.com/max/800/1*MXwyz3kH8ne9PxepWUENjw.jpeg"><figcaption class="imageCaption">Before we can orchestrate containers we need lots of containers!</figcaption></figure><p name="a3af" id="a3af" class="graf graf--p graf-after--figure">Once we have created the images for each application we can move on to an orchestration framework. We chose ECS since it was simple to setup and we were fully committed to AWS already.</p><h4 name="e7e3" id="e7e3" class="graf graf--h4 graf-after--p">ECS</h4><p name="435b" id="435b" class="graf graf--p graf-after--h4">ECS works by forming a logical group of EC2 instances called a cluster. Services are deployed on each cluster. These services ensure that each task we specify is up and running with the correct number of task instances needed to service the current load level. A task is a logical grouping of containers which share resources and linked by local network interface. You should only place containers in the same task if you want them to scale together. In most cases a a task will contain only a single container.</p><p name="a9ed" id="a9ed" class="graf graf--p graf-after--p">As mentioned above, we need to move the applications over to docker since ECS is a container service. Below you will find an example docker file for one of our node applications using the builder pattern to optimise image download size from ECR.</p><figure name="2f14" id="2f14" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mortonprod/91e40672bcfa95f0633df64d696308b9.js"></script></figure><p name="1e56" id="1e56" class="graf graf--p graf-after--figure">We have now built a system which</p><ul class="postList"><li name="db21" id="db21" class="graf graf--li graf-after--p">Checks availability of each service</li><li name="6aa0" id="6aa0" class="graf graf--li graf-after--li">Restarts broken services</li><li name="d592" id="d592" class="graf graf--li graf-after--li">Spreads services between AZs</li><li name="9b47" id="9b47" class="graf graf--li graf-after--li">Quickens deployment updates to minutes</li><li name="6117" id="6117" class="graf graf--li graf-after--li">Keeps constant uptime.</li></ul><p name="58af" id="58af" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Perfect! </strong>However, you still have EC2 instances. You still need to manage those resources and describe to each ECS task how much of the underlying EC2 resources you want to dedicate to it.</p><h3 name="4cf2" id="4cf2" class="graf graf--h3 graf-after--p">Fargate</h3><figure name="db25" id="db25" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*SY5trBUCJib5jHlHY85hXw.png" data-width="900" data-height="271" src="https://cdn-images-1.medium.com/max/800/1*SY5trBUCJib5jHlHY85hXw.png"><figcaption class="imageCaption">Fargate simplifies infrastructure management for many companies by removing the need to monitor the underlying EC2 instances.</figcaption></figure><p name="c0c3" id="c0c3" class="graf graf--p graf-after--figure"><em class="markup--em markup--p-em">How do we solve the issues above?</em></p><p name="d58e" id="d58e" class="graf graf--p graf-after--p">We could employ Fargate to orchestrate our containers without managing EC2 instances. The decision to do this depends on a few factors</p><ul class="postList"><li name="1ab5" id="1ab5" class="graf graf--li graf-after--p">The size of your workloads</li><li name="863d" id="863d" class="graf graf--li graf-after--li">The size of your environments</li><li name="f603" id="f603" class="graf graf--li graf-after--li">The periodicity of your applications</li><li name="c64f" id="c64f" class="graf graf--li graf-after--li">The size and number of each application (ENIs limits)</li></ul><p name="18c2" id="18c2" class="graf graf--p graf-after--li">If you have small workloads or environments or lots of cron jobs then Fargate is perfect for you. You do not want to deploy and manage EC2 instances which you are not utilising.</p><p name="743a" id="743a" class="graf graf--p graf-after--p">The last point is linked to the number of ENIs you can attach to EC2 instances which limits the number of IP addresses you can link to your EC2 instances. This means that ECS will only fill up an EC2 instance with more tasks until it can’t associate more ENIs. So if you have lots of tiny containers then you will be underutilising your EC2 instance since you will only be able to deploy a certain number of containers into your instances.</p><p name="ca7a" id="ca7a" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">This is were you need Fargate. Our applications were tiny node apps so Fargate was a perfect fit for us.</em></p><h4 name="2138" id="2138" class="graf graf--h4 graf-after--p">Disclaimer</h4><p name="670a" id="670a" class="graf graf--p graf-after--h4">Fargate employees a a very particular network strategy known as awsvpc which consumes all ENIs as far as I know. This mean you are very limited in what kind of networks you can setup relative to something like kubernetes. So it was a good fit for us but maybe not yourself. This can even be an issue setting up static ip addresses if, for whatever reason, your application needs that.</p><p name="4779" id="4779" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Note: This last point I am not 100% sure on and would have to do more research. I would definitely say fargate will always be a simpler and therefore a more limited solution compared to many other rivals.</em></strong></p><h3 name="347f" id="347f" class="graf graf--h3 graf-after--p">Implementation</h3><p name="33b5" id="33b5" class="graf graf--p graf-after--h3">The setup of this will depend on your needs. I want to demonstrate our ECS module for setting up applications and focus on those issues since there might be some overlap with your own requirements. Highlights:</p><ul class="postList"><li name="2c7b" id="2c7b" class="graf graf--li graf-after--p">Setting up listeners and target groups</li><li name="d33c" id="d33c" class="graf graf--li graf-after--li">Connecting to ALB and routing</li><li name="cdc3" id="cdc3" class="graf graf--li graf-after--li">Targeted scaling</li><li name="68c6" id="68c6" class="graf graf--li graf-after--li">Task definitions</li></ul><p name="37d7" id="37d7" class="graf graf--p graf-after--li">Below you will see we pass in many arguments to this module. In production we have this setup so we only have to change a single variables file to deploy new applications. This was needed since we have new applications and platforms deployed every other day. This was a good design for us but does mean the terraform code can be rather complex. However, it is between that and duplicating code which was not an option for us due to time constraints and the size of our platform.</p><p name="2ae2" id="2ae2" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Check out the comments below to see more detail about some of the variables and gotchas.</strong></p><figure name="77fb" id="77fb" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mortonprod/4ee0fdbf92ea13d36f03e2246cf0597e.js"></script></figure><p name="b549" id="b549" class="graf graf--p graf-after--figure">Listeners and target groups link our ALB routes to running tasks. They also specify health checks and other options like sticky sessions.</p><p name="6e3c" id="6e3c" class="graf graf--p graf-after--p">CPU and memory util was used for targeted autoscaling. Targeted autoscaling tries to keep these metrics to a fixed value. So you do not under or over utilise your underlying resources.</p><p name="88f0" id="88f0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Note: you should be careful what metric you use with targeted autoscaling. The metric must be something which will decrease linearly as you add or remove task instances.</em></strong></p><p name="812b" id="812b" class="graf graf--p graf-after--p">Terraform creates the task definitions for each app using a template.</p><figure name="7dfd" id="7dfd" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mortonprod/6817e4f8f56bad484a3308649bc0fdd3.js"></script></figure><ul class="postList"><li name="d513" id="d513" class="graf graf--li graf-after--figure">Port numbers are the same for each task now since IP varies using the AWSVPC network mode</li><li name="c116" id="c116" class="graf graf--li graf-after--li">We can attach a log driver without having to install cloudwatch agent on each EC2 instance</li><li name="0a0f" id="0a0f" class="graf graf--li graf-after--li">Task level environment variables</li></ul><p name="96b2" id="96b2" class="graf graf--p graf-after--li">The last point is important. The environment variables at this stage set values which are app independent or anything which will not change. We do not set environment variables at this stage since we want to be able to set new environment variables without re-running terraform. It highlights that configuration is not a single event but can often come in stages. Also note we pass in redis and any other service names we have just created with terraform. This is nice since we don’t have to update a separate config store with information we already have.</p><h3 name="8785" id="8785" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="8198" id="8198" class="graf graf--p graf-after--h3">Fargate is much easier to setup than other alternatives but you need to know exactly what your requirements are before you start. Other solutions exist like Kubernetes or you could continue down the serverless road and end up with a fully serverless solution with AWS lambda.</p><p name="364a" id="364a" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">The decision is yours.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mortonprod" class="p-author h-card">Alexander Morton</a> on <a href="https://medium.com/p/8bd5cdee1c79"><time class="dt-published" datetime="2019-09-22T13:25:29.583Z">September 22, 2019</time></a>.</p><p><a href="https://medium.com/@mortonprod/from-ec2-to-fargate-8bd5cdee1c79" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 24, 2021.</p></footer></article></body></html>