<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to Melt a Webpage</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to Melt a Webpage</h1>
</header>
<section data-field="subtitle" class="p-summary">
Using web-scrapping and WebGL to melt any webpage for fun.
</section>
<section data-field="body" class="e-content">
<section name="3a0d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b359" id="b359" class="graf graf--h3 graf--leading graf--title">How to Melt a Webpage</h3><h4 name="4ead" id="4ead" class="graf graf--h4 graf-after--h3 graf--subtitle">Using web-scrapping and WebGL to melt any webpage for fun.</h4><h3 name="c25f" id="c25f" class="graf graf--h3 graf-after--h4">What It Does</h3><p name="6cbf" id="6cbf" class="graf graf--p graf-after--h3">So I created a website which ‘melts’ other webpages.</p><p name="8b90" id="8b90" class="graf graf--p graf-after--p">Ok let’s be frank: this does not melt webpages. Basically, it finds all ‘greyish’ pixels and then moves them slowly down the page. So you put in any domain name you want and then press the submit button, the submitted webpage is then rendered and when the user clicks a button or scrolls down the page the webpage seems to ‘melt’.</p><p name="d5fe" id="d5fe" class="graf graf--p graf-after--p">The best way of describing this is with an example.</p><figure name="dab0" id="dab0" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/iHR6Zs8kpRo?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">An example of PageMelt working on the StackOverflow website. Source: Image by Author.</figcaption></figure><p name="e693" id="e693" class="graf graf--p graf-after--figure">Another example is shown below demonstrating how to submit a website.</p><figure name="5868" id="5868" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/lWRmKXvrC9U?feature=oembed" width="640" height="480" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">An example of PageMelt working on the BBC website. Source: Image by Author.</figcaption></figure><p name="afb5" id="afb5" class="graf graf--p graf-after--figure">You can learn more about the website by visiting it:</p><div name="f036" id="f036" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://pagemelt.alexandermorton.co.uk/" data-href="https://pagemelt.alexandermorton.co.uk/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://pagemelt.alexandermorton.co.uk/"><strong class="markup--strong markup--mixtapeEmbed-strong">Page Melt</strong><br><em class="markup--em markup--mixtapeEmbed-em">How it Works Enter a domain and see the page instantly melt when you try to scroll or hit the keypad. It basically…</em>pagemelt.alexandermorton.co.uk</a><a href="https://pagemelt.alexandermorton.co.uk/" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="03cba87ee6464c317e37267831b078ac" data-thumbnail-img-id="0*A1pC9C_r85VsJmk9" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*A1pC9C_r85VsJmk9);"></a></div><h3 name="e39f" id="e39f" class="graf graf--h3 graf-after--mixtapeEmbed">Why I Built It</h3><p name="269f" id="269f" class="graf graf--p graf-after--h3">Now the question you might be asking yourself is why would any sane person make this? First of all, sanity is often just a matter of perspective or majority rule; however, I would be pushed to justify those arguments in this case since this project was of a particular wacky nature. So lets try a couple of other justifications:</p><ol class="postList"><li name="572a" id="572a" class="graf graf--li graf-after--p">Cool Technology</li><li name="f917" id="f917" class="graf graf--li graf-after--li">Something I would use</li></ol><h4 name="c85e" id="c85e" class="graf graf--h4 graf-after--li">Technology</h4><p name="468f" id="468f" class="graf graf--p graf-after--h4">A few interesting technologies are used here</p><ul class="postList"><li name="372f" id="372f" class="graf graf--li graf-after--p">Puppeteer</li><li name="1e54" id="1e54" class="graf graf--li graf-after--li">AWS Lambda</li><li name="f6c8" id="f6c8" class="graf graf--li graf-after--li">Chrome AWS Lambda</li><li name="04b5" id="04b5" class="graf graf--li graf-after--li">APIGW</li><li name="7b43" id="7b43" class="graf graf--li graf-after--li">Serverless Framework</li><li name="75ca" id="75ca" class="graf graf--li graf-after--li">CloudFront</li><li name="69f2" id="69f2" class="graf graf--li graf-after--li">S3</li><li name="9a7f" id="9a7f" class="graf graf--li graf-after--li">WebGL</li><li name="c27d" id="c27d" class="graf graf--li graf-after--li">Session Storage</li></ul><p name="ec5a" id="ec5a" class="graf graf--p graf-after--li">A lot of these technologies I use everyday or have used in the past at work so I was not that interest in all of them. My main focus was on WebGL and HTML canvas. I had played about with these in the past but never found a good use case I wanted to publish.</p><h4 name="54b7" id="54b7" class="graf graf--h4 graf-after--p">Something I Would Use</h4><p name="5538" id="5538" class="graf graf--p graf-after--h4">This might be just me and people I know so maybe speaks more to our sense of humour, but for years in university messing about with peoples screens was something we did. Never anything serious to break a computer but enough to throw them off so we could laugh at their confusion.</p><p name="d42d" id="d42d" class="graf graf--p graf-after--p">So recently this came up in conversation with someone and I began to think if there was some service which did this easily. I could find online web-scrappers but nothing which would instantly melt a page on a button click or mouse move. I was told about some apps which did something similar but that would mean downloading an application which I thought lots of people would be opposed to; I know I would be on my machine.</p><p name="e9dd" id="e9dd" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">If there is something similar let me know.</strong></p><h3 name="8e58" id="8e58" class="graf graf--h3 graf-after--p">How It Works</h3><p name="6ebe" id="6ebe" class="graf graf--p graf-after--h3">There is not much to it when you get over the first few hurdles.</p><p name="1008" id="1008" class="graf graf--p graf-after--p">I originally wanted to do everything on the browser since this would save me having to setup any server; however, after a quick think I realised this would be impossible since I would fall foul to CORS: Most website servers, at least the ones which care about security, set the ‘Access-Control-Allow-Origin’ header to tell the browser what domains can access it’s endpoint. This would make most websites render incorrectly. So I knew I needed to scrape on an external server.</p><h4 name="908f" id="908f" class="graf graf--h4 graf-after--p">Backend</h4><p name="83cd" id="83cd" class="graf graf--p graf-after--h4">This is more costly and I was not willing to pay more than pennies a month for a joke website so AWS lambda was the only option. This did not completely assuage my concerns since I was now worried about memory usage and size limits. Memory usage could be quite large for having to run a headless browser, and if I had to package one into a lambda I could be well over the 50MB size limit.</p><p name="d8e4" id="d8e4" class="graf graf--p graf-after--p">After a bit of a reading around I found <a href="https://codissimo.sinumo.tech/2019/12/27/serverless-puppeteer-with-aws-lambda-layers-and-node-js/" data-href="https://codissimo.sinumo.tech/2019/12/27/serverless-puppeteer-with-aws-lambda-layers-and-node-js/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this article</a> which alleviated my concerns about the overall size of the function. Additionally, it also specified an existing AWS lambda layer for headless chrome so I no longer had to make by own layer giving me less work. The example also used puppeteer which provides an API in nodeJS to control headless chrome which I was using already for my experiments so I did not have to change this either. <strong class="markup--strong markup--p-strong">Complete win!</strong></p><p name="75cf" id="75cf" class="graf graf--p graf-after--p">You can see the final lambda function which does everything the PageMelt website needs:</p><figure name="d44a" id="d44a" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mortonprod/a1927d8f3fd5740ef2e58a25ea28503a#file-pagemelt-lambda-js.js"></script><figcaption class="imageCaption">AWS lambda function to web-scrape webpages and store output in s3. Source: Image by Author.</figcaption></figure><p name="0f19" id="0f19" class="graf graf--p graf-after--figure">A few things to note:</p><ul class="postList"><li name="af69" id="af69" class="graf graf--li graf-after--p">Placed in CORS check to offer very limited security check</li><li name="5ef6" id="5ef6" class="graf graf--li graf-after--li">Takes in clients browser size and type which we pass to puppeteer</li><li name="8301" id="8301" class="graf graf--li graf-after--li">Saves the output of screenshot to an s3 bucket</li><li name="ef0c" id="ef0c" class="graf graf--li graf-after--li">Generates a signed URL to pass to the browser which will only work for 30 seconds</li><li name="ebd2" id="ebd2" class="graf graf--li graf-after--li">Keep the quality of the screenshot to 30 and use jpg to keep storage size to a minimum</li><li name="076b" id="076b" class="graf graf--li graf-after--li">Ensure the browser stores the image so it can be rerun without having to call s3 again after 30 second timeout</li></ul><p name="3314" id="3314" class="graf graf--p graf-after--li"><em class="markup--em markup--p-em">I store the screenshot in s3 but I could have just pushed the jpg to the browser from the lambda function; however, the cost was relatively small and I was wanted to see what screenshots people were taking.</em></p><p name="ed72" id="ed72" class="graf graf--p graf-after--p">With this lambda we can now deploy using the Serverless framework:</p><figure name="9e7b" id="9e7b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/mortonprod/47eb84f803e3545b9ecdeea6faa91e90#file-pagemelt-serverless-yml.js"></script><figcaption class="imageCaption">Serverless framework setup for the backend infrastructure. Source: Image by Author.</figcaption></figure><p name="09c8" id="09c8" class="graf graf--p graf-after--figure">A few things to note:</p><ul class="postList"><li name="456e" id="456e" class="graf graf--li graf-after--p">Setup CORS on the bucket as some limited security</li><li name="40f7" id="40f7" class="graf graf--li graf-after--li">Throttle the API calls to 10 a second since this is only a test site to begin with and we don’t want to be swamped by some nefarious user</li><li name="8ab2" id="8ab2" class="graf graf--li graf-after--li">Limit the total number of calls to 10,000 to mitigate the damage of wicked users</li><li name="750f" id="750f" class="graf graf--li graf-after--li">Pass in the pre-made ‘chrome-aws-lambda’ layer since there is no point recreating this</li></ul><p name="6c72" id="6c72" class="graf graf--p graf-after--li">Now we have the backend setup we need to turn to the frontend.</p><h4 name="dfd7" id="dfd7" class="graf graf--h4 graf-after--p">Frontend</h4><p name="c127" id="c127" class="graf graf--p graf-after--h4">We need to get the information needed by the lambda from the frontend. This is quite simple and just involves collecting the information, passing it to the lambda and getting the URL of the s3 bucket image we want to download. Since we are moving from the index.html page to the canvas.html page to render the scraped webpage we store the s3 domain in session storage.</p><figure name="8bc6" id="8bc6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*m29KuyfzPoC9R5L-4wPvGQ.jpeg" data-width="1013" data-height="584" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*m29KuyfzPoC9R5L-4wPvGQ.jpeg"><figcaption class="imageCaption">The form Javascript code used in index.html. Source: Image by Author.</figcaption></figure><p name="7612" id="7612" class="graf graf--p graf-after--figure">Once we have the s3 image name on the canvas.html page we can render this as a HTML img which is then moved on to a canvas element. We must ensure that we don’t render the canvas element until the img is loaded from the server. Additionally, we must also make sure that all window listeners are called only once or we will crash our browser calling canvas updates again and again and again….</p><figure name="a953" id="a953" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*W4xClI7XFX9dEmVUSRepVQ.jpeg" data-width="678" data-height="401" src="https://cdn-images-1.medium.com/max/800/1*W4xClI7XFX9dEmVUSRepVQ.jpeg"><figcaption class="imageCaption">The start of the Javascript code used in canvas.html. Source: Image by Author.</figcaption></figure><p name="08d3" id="08d3" class="graf graf--p graf-after--figure">Next we to consider how we will update the pixels. As a start I wanted to just move ‘greyish’ pixels down the page.</p><figure name="d806" id="d806" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3buPkSepctgdZGqrusHdMA.jpeg" data-width="727" data-height="560" src="https://cdn-images-1.medium.com/max/800/1*3buPkSepctgdZGqrusHdMA.jpeg"><figcaption class="imageCaption">This will start from the bottom of the page and move down the pixels one by one. Source: Image by Author.</figcaption></figure><p name="988a" id="988a" class="graf graf--p graf-after--figure">Next we do the same thing again but now the pixels are dripping down the page and not dropping.</p><figure name="ccd4" id="ccd4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*faFk3G-0lm_AN66iM_J_jA.jpeg" data-width="734" data-height="409" src="https://cdn-images-1.medium.com/max/800/1*faFk3G-0lm_AN66iM_J_jA.jpeg"><figcaption class="imageCaption">This will start from the bottom of the page and move down pixels one by one but not removing the grey pixels above. Source: Image by Author.</figcaption></figure><p name="7a91" id="7a91" class="graf graf--p graf-after--figure">The term ‘greyish’ is defined below. Basically, if the RGB values are similar and under a certain threshold then they are defined as grey. This is done using the equation for variance which most people would be familiar with.</p><figure name="b3e8" id="b3e8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5dNUkeiUFMr4i8DerqSOVA.jpeg" data-width="776" data-height="312" src="https://cdn-images-1.medium.com/max/800/1*5dNUkeiUFMr4i8DerqSOVA.jpeg"><figcaption class="imageCaption">Calculate what pixels are grey and should be moved. Source: Image by Author.</figcaption></figure><p name="670e" id="670e" class="graf graf--p graf-after--figure">Converting pixels from 1D format of the image data to 2D grid we are familiar with is done below. The thing to note is that the 1D image stacks up RGBA values for each pixel one after the other; so you can transform between them using a simple formula.</p><figure name="5906" id="5906" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*j71YpcjWSTgGr1ufVg8w_w.jpeg" data-width="390" data-height="340" src="https://cdn-images-1.medium.com/max/800/1*j71YpcjWSTgGr1ufVg8w_w.jpeg"><figcaption class="imageCaption">Formula for transforming between data types. Source: Image by Author.</figcaption></figure><p name="bf29" id="bf29" class="graf graf--p graf-after--figure">Once this is all setup we package the code with Webpack and deploy using a Github action to a s3 bucket behind CloudFront. Security headers and basic routing is provided by lambda edge functions.</p><h3 name="d2de" id="d2de" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="6a32" id="6a32" class="graf graf--p graf-after--h3">This might seem like a complete waste of time but I really enjoyed this project since I love the potential of WebGL in the browser. You can find lots of better examples of WebGL but I liked the strangeness of this. One person described it as modern art but I would not go that far; <em class="markup--em markup--p-em">I just think it looks funny.</em></p><p name="abd6" id="abd6" class="graf graf--p graf-after--p graf--trailing">There are a few things I can think of doing to improve this project like identifying the text using optical character recognition and making that fall but that would be for another day.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@mortonprod" class="p-author h-card">Alexander Morton</a> on <a href="https://medium.com/p/4fd6cf2cb80e"><time class="dt-published" datetime="2020-12-30T18:46:39.512Z">December 30, 2020</time></a>.</p><p><a href="https://medium.com/@mortonprod/how-to-melt-a-webpage-4fd6cf2cb80e" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on July 24, 2021.</p></footer></article></body></html>